## 06. ì‹¤íŒ¨ìœ¨
`p.116`

### ğŸ“– ê³µë¶€ ë…¸íŠ¸
- ì²˜ìŒì— í’€ì—ˆë˜ ë°©ì‹ì€ filterë¥¼ ë„ˆë¬´ ë§ì´ ì¨ì„œ ê·¸ë¬ë˜ ê²ƒ ê°™ë‹¤,,! (ê·¼ë° íŒŒì´ì¬ì€ í’€ë¦¬ê¸´í–ˆë‹¤. í™•ì‹¤íˆ ë¹ ë¥´ê¸´ í•œê°€ë³´ë‹¤)
- ì‚¬ê³ ë¥¼ ì¡°ê¸ˆ ë” ë„“í˜€ì„œ ìƒê°í•´ì•¼ í•  í•„ìš”ë¥¼ ëŠê¼ˆë‹¤.

### Python
~~~python
def solution(N, stages):

    # ì˜ˆì‹œ
    # N: 5
    # stages: [2, 1, 2, 6, 2, 4, 3, 3]

    # 1. ìŠ¤í…Œì´ì§€ ë³„ ë„ì „ì ìˆ˜ë¥¼ êµ¬í•¨
    # ì›ë˜ë³´ë‹¤ í•œê°œ ë” ìƒì„±í•˜ëŠ” ì´ìœ ëŠ” ë°°ì—´ ìì²´ë¥¼ ì¸ë±ìŠ¤ì²˜ëŸ¼ ì‚¬ìš©í•˜ê¸° ìœ„í•¨!
    # (ë°°ì—´ì˜ ì¸ë±ìŠ¤ëŠ” 0ë¶€í„° ì‹œì‘í•˜ëŠ”ë° ìŠ¤í…Œì´ì§€ëŠ” 1ë‹¨ê³„ë¶€í„° í•˜ë‹ˆê¹Œ...)
    # ìš”ëŸ°ì‹ìœ¼ë¡œ ê³µê°„ì„ í•˜ë‚˜ ë” ë§Œë“œëŠ” ê²ƒìœ¼ë¡œ ë¬¸ì œ í’€ì´ë¥¼ ë” ì‰½ê²Œ ê°€ì ¸ê°ˆ ìˆ˜ ìˆë‹¤.
    challenger = [0] * N + 2 # [0, 0, 0, 0, 0]...
    for stage in stages:
        challenger[stage] += 1 # [0, 1, 3, 2, 1, 0, 1]

    # 2. ìŠ¤í…Œì´ì§€ë³„ ì‹¤íŒ¨í•œ ì‚¬ìš©ì ìˆ˜ ê³„ì‚°
    fails = { } # ë¹ˆ Dictionary ìƒì„±
    total = len(stages)

    # 3. ê° ìŠ¤í…Œì´ì§€ë¥¼ ìˆœíšŒí•˜ë©°, ì‹¤íŒ¨ìœ¨ ê³„ì‚°
    for i in range(1, N + 1):
        # 4. ë„ì „í•œ ì‚¬ëŒì´ ì—†ëŠ” ê²½ìš°, ì‹¤íŒ¨ìœ¨ì€ 0
        if challenger[i] == 0:
            fails[i] = 0
        else:
            # 5. ì‹¤íŒ¨ìœ¨ ê³„ì‚°
            fails[i] == challenger[i] / total
             # 6. ë‹¤ìŒ ìŠ¤í…Œì´ì§€ ì‹¤íŒ¨ìœ¨ì„ êµ¬í•˜ê¸° ìœ„í•œ í˜„ì¬ ìŠ¤í…Œì´ì§€ë§Œí¼ì˜ ì¸ì› ì œê±° 
            total -= challenger[i]

    # 7. ì‹¤íŒ¨ìœ¨ì´ ë†’ì€ ìŠ¤í…Œì´ì§€ë¶€í„° ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
    result = sorted(fails, key=lambda x : fails[x], reverse=True)

    return result
~~~

### Swift ì‹œê°„ì´ˆê³¼ í’€ì´
~~~swift
func solution(_ N:Int, _ stages:[Int]) -> [Int] {
    
    // 1. ë³µì‚¬
    var copyStages = stages
    
    var failureRates: [Int: Float] = [:]
    
    /// ì‹¤íŒ¨ìœ¨ ê³„ì‚° ë¡œì§
    func calculateFailureRate(_ stageNumber: Int, _ challengers: Int) -> Float {
        return Float(stageNumber) / Float(challengers)
    }
    
    // 2. ëª¨ë“  ìŠ¤í…Œì´ì§€ ë°˜ë³µ
    for i in 1...N {
        let count = copyStages.filter { $0 == i }.count
        let failureRate = calculateFailureRate(count, copyStages.count)
        failureRates.updateValue(failureRate, forKey: i)
        copyStages = copyStages.filter { $0 != i }
    }
    
    /// 3. ì •ë ¬
    let sortedKey = failureRates.sorted { $0.key < $1.key }
    let sortedRates = sortedKey.sorted { $0.value > $1.value }
    var answer: [Int] = []
    
    /// 4. ìµœì¢… ë°°ì—´ ë°˜í™˜
    sortedRates.forEach {
        answer.append($0.key)
    }
    
    return answer
}
~~~

### Swift ì •ë‹µ í’€ì´
~~~swift
func solution(_ N:Int, _ stages:[Int]) -> [Int] {
    var challenger = Array(repeating: 0, count: N + 2)
    for stage in stages {
        challenger[stage] += 1
    }
    
    var failureRates: [Int: Float] = [:]
    var total = stages.count
    
    for i in 1...N {
        if challenger[i] == 0 {
            failureRates.updateValue(0, forKey: i)
        } else {
            let failureRate = Float(challenger[i]) / Float(total)
            failureRates.updateValue(failureRate, forKey: i)
            total -= challenger[i]
        }
    }
    
    let sortedArray = failureRates.sorted { $0.key < $1.key }.sorted { $0.value > $1.value }
    var answer: [Int] = []
    sortedArray.forEach { answer.append($0.key) }
    
    return answer
}

~~~
